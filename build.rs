use std::env;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::PathBuf;

type Bitboard = u64;

// Helper functions for attack generation
fn file_of(sq: i32) -> i32 {
    sq & 7
}
fn in_board(sq: i32) -> bool {
    (0..64).contains(&sq)
}

struct Rng(u64);
impl Rng {
    fn new() -> Self {
        Self(0x1234_5678_9ABC_DEF0)
    }
    fn rand(&mut self) -> u64 {
        self.0 ^= self.0 >> 12;
        self.0 ^= self.0 << 25;
        self.0 ^= self.0 >> 27;
        self.0.wrapping_mul(0x2545_F491_4F6C_DD1D)
    }
    fn rand_sparse(&mut self) -> u64 {
        self.rand() & self.rand() & self.rand()
    }
}

fn slider_mask(sq: usize, is_rook: bool) -> Bitboard {
    let mut result = 0;
    let r = sq / 8;
    let f = sq % 8;
    let deltas = if is_rook {
        [(1, 0), (-1, 0), (0, 1), (0, -1)]
    } else {
        [(1, 1), (1, -1), (-1, 1), (-1, -1)]
    };
    for (dr, df) in deltas {
        let (mut cr, mut cf) = (r as i32 + dr, f as i32 + df);
        while (0..8).contains(&cr) && (0..8).contains(&cf) {
            let next_r = cr + dr;
            let next_f = cf + df;
            if (0..8).contains(&next_r) && (0..8).contains(&next_f) {
                result |= 1u64 << (cr * 8 + cf) as usize;
            }
            cr += dr;
            cf += df;
        }
    }
    result
}

fn slider_attacks(sq: usize, blockers: Bitboard, is_rook: bool) -> Bitboard {
    let mut attacks = 0;
    let r = sq / 8;
    let f = sq % 8;
    let deltas = if is_rook {
        [(1, 0), (-1, 0), (0, 1), (0, -1)]
    } else {
        [(1, 1), (1, -1), (-1, 1), (-1, -1)]
    };
    for (dr, df) in deltas {
        let (mut cr, mut cf) = (r as i32 + dr, f as i32 + df);
        while (0..8).contains(&cr) && (0..8).contains(&cf) {
            let to_sq = (cr * 8 + cf) as usize;
            attacks |= 1u64 << to_sq;
            if (blockers & (1u64 << to_sq)) != 0 {
                break;
            }
            cr += dr;
            cf += df;
        }
    }
    attacks
}

fn find_magic_for_sq(sq: usize, is_rook: bool, rng: &mut Rng) -> (u64, Vec<u64>) {
    let mask = slider_mask(sq, is_rook);
    let bits = mask.count_ones();
    let table_size = 1 << bits;
    let mut occupancies = Vec::with_capacity(table_size);
    let mut attacks = Vec::with_capacity(table_size);
    let mut b: Bitboard = 0;
    loop {
        occupancies.push(b);
        attacks.push(slider_attacks(sq, b, is_rook));
        b = (b.wrapping_sub(mask)) & mask;
        if b == 0 {
            break;
        }
    }
    loop {
        let magic = rng.rand_sparse();
        if (mask.wrapping_mul(magic) >> 56).count_ones() < 6 {
            continue;
        }
        let mut used_indices: Vec<Option<u64>> = vec![None; table_size];
        let mut collision = false;
        for i in 0..table_size {
            let occ = occupancies[i];
            let index = (occ.wrapping_mul(magic) >> (64 - bits)) as usize;
            let current_attack = attacks[i];
            if let Some(existing_attack) = used_indices[index] {
                if existing_attack != current_attack {
                    collision = true;
                    break;
                }
            } else {
                used_indices[index] = Some(current_attack);
            }
        }
        if !collision {
            let mut table = vec![0; table_size];
            for i in 0..table_size {
                let occ = occupancies[i];
                let index = (occ.wrapping_mul(magic) >> (64 - bits)) as usize;
                table[index] = attacks[i];
            }
            return (magic, table);
        }
    }
}

/// Generates all attack tables and writes them to a single .rs file.
fn generate_attacks_source(out_dir: &PathBuf) {
    let dest_path = out_dir.join("generated_attacks.rs");
    let mut f = BufWriter::new(File::create(&dest_path).unwrap());

    writeln!(
        f,
        "// This file is generated by build.rs. Do not edit by hand."
    )
    .unwrap();

    let mut white_pawn_attacks = [0u64; 64];
    let mut black_pawn_attacks = [0u64; 64];
    let mut knight_attacks = [0u64; 64];
    let mut king_attacks = [0u64; 64];

    const KNIGHT_DELTAS: [i32; 8] = [6, 10, 15, 17, -6, -10, -15, -17];
    const KING_DELTAS: [i32; 8] = [1, -1, 8, -8, 7, 9, -7, -9];

    for sq in 0..64 {
        let sq_i32 = sq as i32;
        // Pawns
        if sq_i32 / 8 < 7 {
            if sq_i32 % 8 > 0 {
                white_pawn_attacks[sq] |= 1u64 << (sq + 7);
            }
            if sq_i32 % 8 < 7 {
                white_pawn_attacks[sq] |= 1u64 << (sq + 9);
            }
        }
        if sq_i32 / 8 > 0 {
            if sq_i32 % 8 > 0 {
                black_pawn_attacks[sq] |= 1u64 << (sq - 9);
            }
            if sq_i32 % 8 < 7 {
                black_pawn_attacks[sq] |= 1u64 << (sq - 7);
            }
        }
        // Knights
        for d in KNIGHT_DELTAS {
            let to = sq_i32 + d;
            if in_board(to) && (file_of(sq_i32) - file_of(to)).abs() <= 2 {
                knight_attacks[sq] |= 1u64 << to;
            }
        }
        // Kings
        for d in KING_DELTAS {
            let to = sq_i32 + d;
            if in_board(to) && (file_of(sq_i32) - file_of(to)).abs() <= 1 {
                king_attacks[sq] |= 1u64 << to;
            }
        }
    }

    // Write all leaper tables
    for (name, table) in [
        ("WHITE_PAWN_ATTACKS", &white_pawn_attacks),
        ("BLACK_PAWN_ATTACKS", &black_pawn_attacks),
        ("KNIGHT_ATTACKS", &knight_attacks),
        ("KING_ATTACKS", &king_attacks),
    ] {
        writeln!(f, "\npub const {}: [Bitboard; 64] = [", name).unwrap();
        for (i, &attack) in table.iter().enumerate() {
            write!(f, "0x{:X},", attack).unwrap();
            if (i + 1) % 8 == 0 {
                writeln!(f).unwrap();
            }
        }
        writeln!(f, "];").unwrap();
    }

    let mut rng = Rng::new();
    let mut rook_attack_table = Vec::new();
    let mut bishop_attack_table = Vec::new();

    println!("cargo:warning=Generating Rook magic bitboard tables...");
    for sq in 0..64 {
        let (_, mut table) = find_magic_for_sq(sq, true, &mut rng);
        rook_attack_table.append(&mut table);
    }

    println!("cargo:warning=Generating Bishop magic bitboard tables...");
    for sq in 0..64 {
        let (_, mut table) = find_magic_for_sq(sq, false, &mut rng);
        bishop_attack_table.append(&mut table);
    }

    writeln!(
        f,
        "\npub const ROOK_ATTACKS: [Bitboard; {}] = [",
        rook_attack_table.len()
    )
    .unwrap();
    for (i, &attack) in rook_attack_table.iter().enumerate() {
        write!(f, "0x{:016X},", attack).unwrap();
        if (i + 1) % 8 == 0 {
            writeln!(f).unwrap();
        }
    }
    writeln!(f, "];").unwrap();

    writeln!(
        f,
        "\npub const BISHOP_ATTACKS: [Bitboard; {}] = [",
        bishop_attack_table.len()
    )
    .unwrap();
    for (i, &attack) in bishop_attack_table.iter().enumerate() {
        write!(f, "0x{:016X},", attack).unwrap();
        if (i + 1) % 8 == 0 {
            writeln!(f).unwrap();
        }
    }
    writeln!(f, "];").unwrap();

    println!(
        "cargo:warning=Wrote all attack tables to {}",
        dest_path.display()
    );
}

/// Downloads the NNUE file
fn download_nnue(out_dir: &PathBuf) {
    const NNUE_URL: &str = "https://tests.stockfishchess.org/api/nn/nn-9931db908a9b.nnue";
    let dest_path = out_dir.join("nn-9931db908a9b.nnue");

    if dest_path.exists() {
        return;
    }

    println!("cargo:warning=Downloading NNUE file from {}", NNUE_URL);
    let response = reqwest::blocking::get(NNUE_URL).expect("Failed to download NNUE file");
    let bytes = response
        .bytes()
        .expect("Failed to get bytes from NNUE download response");

    let mut dest_file = File::create(&dest_path).expect("Failed to create NNUE file");
    dest_file
        .write_all(&bytes)
        .expect("Failed to write to NNUE file");
}

fn generate_zobrist_keys(out_dir: &PathBuf) {
    let dest_path = out_dir.join("generated_zobrist.rs");
    let mut f = BufWriter::new(File::create(&dest_path).unwrap());

    writeln!(
        f,
        "// This file is generated by build.rs. Do not edit by hand."
    )
    .unwrap();
    writeln!(f, "use crate::types::ZKey;").unwrap();

    fn splitmix64(state: &mut u64) -> u64 {
        *state = state.wrapping_add(0x9E37_79B9_7F4A_7C15);
        let mut x = *state;
        x = (x ^ (x >> 30)).wrapping_mul(0xBF58_476D_1CE4_E5B9);
        x = (x ^ (x >> 27)).wrapping_mul(0x94D0_49BB_1331_11EB);
        x ^ (x >> 31)
    }
    let mut seed: u64 = 0x1234_5678_9ABC_DEF0;

    // Generate the keys
    writeln!(f, "\npub const ZOBRIST_KEYS: Zobrist = Zobrist {{").unwrap();

    // Piece keys
    writeln!(f, "    piece: [").unwrap();
    for _ in 0..13 {
        writeln!(f, "        [").unwrap();
        for _ in 0..64 {
            writeln!(f, "            0x{:016X},", splitmix64(&mut seed)).unwrap();
        }
        writeln!(f, "        ],").unwrap();
    }
    writeln!(f, "    ],").unwrap();

    // Castle keys
    writeln!(f, "    castle: [").unwrap();
    for _ in 0..16 {
        writeln!(f, "        0x{:016X},", splitmix64(&mut seed)).unwrap();
    }
    writeln!(f, "    ],").unwrap();

    // EP file keys
    writeln!(f, "    ep_file: [").unwrap();
    for _ in 0..8 {
        writeln!(f, "        0x{:016X},", splitmix64(&mut seed)).unwrap();
    }
    writeln!(f, "    ],").unwrap();

    // Side key
    writeln!(f, "    side: 0x{:016X},", splitmix64(&mut seed)).unwrap();

    writeln!(f, "}};").unwrap();
}

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    generate_attacks_source(&out_dir);
    download_nnue(&out_dir);
    generate_zobrist_keys(&out_dir);
    println!("cargo:rerun-if-changed=build.rs");
}
